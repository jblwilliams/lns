package caddy

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"lns/internal/config"
	"lns/internal/models"
	"lns/internal/registry"
)

type UpstreamMode int

const (
	UpstreamModeHost UpstreamMode = iota
	UpstreamModeDockerNetwork
)

func GenerateServiceBlock(service *models.Service, projectPrefix string, httpPort int, upstreamMode UpstreamMode) string {
	hostname := service.GetHostname(projectPrefix)
	upstream := getUpstream(service, upstreamMode)

	info := models.GetFrameworkInfo(service.Framework)

	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("http://%s:%d {\n", hostname, httpPort))

	if info.NeedsHMR {
		sb.WriteString(fmt.Sprintf("    reverse_proxy %s {\n", upstream))
		sb.WriteString("        header_up Host {host}\n")
		sb.WriteString("        header_up X-Real-IP {remote_host}\n")
		sb.WriteString("        header_up X-Forwarded-For {remote_host}\n")
		sb.WriteString("        header_up X-Forwarded-Proto {scheme}\n")
		sb.WriteString("    }\n")
	} else {
		sb.WriteString(fmt.Sprintf("    reverse_proxy %s\n", upstream))
	}

	sb.WriteString("}")

	return sb.String()
}

func GenerateProjectCaddyfile(project *models.Project, httpPort int, upstreamMode UpstreamMode) string {
	if len(project.Services) == 0 {
		return fmt.Sprintf("# Project: %s (no services configured)\n", project.Name)
	}

	prefix := project.GetPrefix()
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("# Project: %s\n", project.Name))
	if project.Path != "" {
		sb.WriteString(fmt.Sprintf("# Path: %s\n", project.Path))
	}
	sb.WriteString("\n")

	for i := range project.Services {
		sb.WriteString(GenerateServiceBlock(&project.Services[i], prefix, httpPort, upstreamMode))
		sb.WriteString("\n\n")
	}

	return sb.String()
}

func GenerateGlobalCaddyfile(httpPort int, adminAddr string) string {
	caddyConfigDir := config.GetCaddyConfigDir()
	globalPath := config.GetGlobalCaddyfilePath()

	return fmt.Sprintf(`# LNS - Global Caddyfile
# Auto-generated by lns - do not edit manually
#
# This file imports all project-specific configurations.
# To reload after changes: lns reload
# Or: caddy reload --config %s --address %s

{
    auto_https off
    admin %s
    http_port %d
}

	import %s/*.caddy
	`, globalPath, adminAddr, adminAddr, httpPort, caddyConfigDir)
}

func WriteProjectCaddyfile(project *models.Project) (string, error) {
	caddyConfigDir := config.GetCaddyConfigDir()

	if err := os.MkdirAll(caddyConfigDir, 0755); err != nil {
		return "", err
	}

	configPath := filepath.Join(caddyConfigDir, projectConfigBasename(project.Name)+".caddy")

	settings, err := config.LoadSettings()
	if err != nil {
		return "", err
	}

	content := GenerateProjectCaddyfile(project, settings.HTTPPort, UpstreamModeHost)
	if err := os.WriteFile(configPath, []byte(content), 0644); err != nil {
		return "", err
	}

	return configPath, nil
}

func WriteGlobalCaddyfile() (string, error) {
	globalPath := config.GetGlobalCaddyfilePath()

	if err := os.MkdirAll(filepath.Dir(globalPath), 0755); err != nil {
		return "", err
	}

	settings, err := config.LoadSettings()
	if err != nil {
		return "", err
	}

	content := GenerateGlobalCaddyfile(settings.HTTPPort, settings.AdminAddr)
	if err := os.WriteFile(globalPath, []byte(content), 0644); err != nil {
		return "", err
	}

	return globalPath, nil
}

func RemoveProjectCaddyfile(projectName string) error {
	caddyConfigDir := config.GetCaddyConfigDir()

	configPath := filepath.Join(caddyConfigDir, projectConfigBasename(projectName)+".caddy")

	err := os.Remove(configPath)
	if os.IsNotExist(err) {
		return nil
	}
	return err
}

func projectConfigBasename(projectName string) string {
	name := strings.ToLower(strings.TrimSpace(projectName))
	if name == "" {
		return "project"
	}

	var b strings.Builder
	b.Grow(len(name))

	prevDash := false
	for _, r := range name {
		switch {
		case unicode.IsLetter(r) || unicode.IsDigit(r):
			b.WriteRune(r)
			prevDash = false
		case r == '-' || r == '_':
			b.WriteRune(r)
			prevDash = false
		default:
			if !prevDash {
				b.WriteByte('-')
				prevDash = true
			}
		}
	}

	s := strings.Trim(b.String(), "-")
	if s == "" {
		return "project"
	}
	if runes := []rune(s); len(runes) > 120 {
		return string(runes[:120])
	}
	return s
}

func RegenerateAllCaddyfiles() ([]string, error) {
	mgr, err := registry.NewManager()
	if err != nil {
		return nil, err
	}

	var paths []string

	globalPath, err := WriteGlobalCaddyfile()
	if err != nil {
		return nil, err
	}
	paths = append(paths, globalPath)

	for _, project := range mgr.Registry.Projects {
		path, err := WriteProjectCaddyfile(&project)
		if err != nil {
			return paths, err
		}
		paths = append(paths, path)
	}

	return paths, nil
}

func GenerateStandaloneCaddyfile(project *models.Project, port int, upstreamMode UpstreamMode) string {
	prefix := project.GetPrefix()
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf(`# Standalone Caddyfile for %s
	# Generated by lns
	#
# Usage:
#   caddy run --config Caddyfile
#   OR add to docker-compose.yml

{
    auto_https off
    http_port %d
}

	`, project.Name, port))

	for i := range project.Services {
		sb.WriteString(GenerateServiceBlock(&project.Services[i], prefix, port, upstreamMode))
		sb.WriteString("\n\n")
	}

	return sb.String()
}

func getUpstream(service *models.Service, mode UpstreamMode) string {
	if mode == UpstreamModeDockerNetwork {
		return service.GetDockerUpstream()
	}
	return service.GetUpstream()
}

func GenerateDockerComposeSnippet(project *models.Project, httpPort int) string {
	network := project.DockerNetwork
	if network == "" {
		network = "app_network"
	}

	var dependsOn strings.Builder
	for _, service := range project.Services {
		if service.Docker && service.ContainerName != "" {
			dependsOn.WriteString(fmt.Sprintf("      - %s\n", service.ContainerName))
		}
	}

	deps := dependsOn.String()
	if deps == "" {
		deps = "      []"
	} else {
		deps = strings.TrimSuffix(deps, "\n")
	}

	return fmt.Sprintf(`# Add this to your docker-compose.yml services section
caddy:
    image: caddy:2-alpine
    ports:
        - "%d:%d"
    volumes:
        - ./Caddyfile:/etc/caddy/Caddyfile:ro
    networks:
        - %s
    restart: unless-stopped
    depends_on:
%s
`, httpPort, httpPort, network, deps)
}
